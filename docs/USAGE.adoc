= systing(8)
:doctype: manpage
:toc: true
:toclevels: 1

////
Style guide:
- one sentence per line
////

== Name

systing - a tracing tool for generating perfetto traces

== Synopsis

*systing* [_OPTIONS_]

== Description

systing is a tracing tool for generating perfetto traces of the system.
It was written with the intention of being a simple and easy to use tool for generating https://perfetto.dev[Perfetto] traces with the least amount of configuration possible.
It is opinionated about what is the most useful information to get out of the system for doing low level system performance investigations.

== Examples

Trace all the scheduling events and stack traces for all threads in the system for 60 seconds::
----
# systing --duration 60
----

Trace only a qemu process and record every time it calls `v9fs_create`::
----
# systing --duration 60 --trace-event "usdt:/usr/bin/qemu-system-x86_64:qemu:v9fs_create" --trace-event-pid <pid>
----

== Options

=== *--add-recorder* _RECORDER_

Enable a specific recorder by name in addition to the default enabled recorders.
This option can be specified multiple times to enable multiple recorders.
Use *--list-recorders* to see available recorders and their default states.

Available recorders:

* `sched` - Scheduler event tracing (enabled by default)
* `syscalls` - Syscall tracing (disabled by default)
* `sleep-stacks` - Sleep stack traces (enabled by default)
* `cpu-stacks` - CPU perf stack traces (enabled by default)
* `pystacks` - Python stack tracing (disabled by default, requires pystacks feature)

Examples:
----
# Enable syscalls in addition to default recorders
# systing --add-recorder syscalls --duration 60

# Enable both syscalls and pystacks
# systing --add-recorder syscalls --add-recorder pystacks --duration 60
----

=== *--cgroup* _PATH_

Record only processes that belong to this cgroup.
This can be specified multiple times to record multiple cgroups.

With this option we will still record processes that are not in the cgroup but that wakeup a process in our cgroup.
This creates odd artifacts in the scheduler tracks but is useful for debugging.

=== *--continuous* _SECONDS_

Run the trace continuously in a ringbuffer that lasts _SECONDS_.
This will not stop the trace after _SECONDS_ but will instead continue to run until the user stops it.
This is useful for long running traces where you want to keep the trace running and only stop it when you are done.
You can use this in conjunction with the `stop_triggers` option in the *--trace-event-config* option to stop the trace when a certain condition is met.

An example usecase is when attempting to catch a rare occurring latency event.

=== *--cpu-frequency*

Record the CPU frequency of every CPU in the system.
When this is enabled systing will record the CPU frequency of every CPU in the system every 100ms.
This will be added a global track per-CPU in the trace.

=== *--cpu-sched-stats*

Record individual CPU scheduling statistics per CPU and per thread.
This generates a lot of data and is not recommended for long traces.
This will generate 2 tracks in the global track for each CPU in the system.
The first will contain the number of entities in the runqueue for each CPU at the given timestamp.
The second is the current wakeup latency for this CPU at the given timestamp.

=== *--duration*

Specifies the duration of the trace in seconds.

=== *--enable-debuginfod*

Enable debuginfod for enhanced symbol resolution.
When enabled, systing will attempt to fetch debug information for binaries using the debuginfod protocol.
This can significantly improve the quality of stack traces by providing more accurate symbol names and source code information.
It will also increase the amount of time required to generate traces.

To use this feature, you must set the `DEBUGINFOD_URLS` environment variable to point to one or more debuginfod servers.
For example:
----
export DEBUGINFOD_URLS="https://debuginfod.fedoraporject.org/"
# systing --enable-debuginfod --duration 60
----

If debuginfod is not available or fails to fetch debug information, systing will fall back to the default symbol resolution methods.
This option is disabled by default to avoid unexpected network requests.

=== *--list-recorders*

List all available recorders and their default states.
This is useful for discovering which recorders are available and which ones are enabled by default.
Use this in conjunction with *--add-recorder* or *--only-recorder* to control which recorders are active.

Example:
----
# systing --list-recorders
Available recorders:
  sched          - Scheduler event tracing (on by default)
  syscalls       - Syscall tracing
  sleep-stacks   - Sleep stack traces (on by default)
  cpu-stacks     - CPU perf stack traces (on by default)
  pystacks       - Python stack tracing
----

=== *--no-cpu-stack-traces*

Do not record the `perf` style stack traces for tasks while they're running.

=== *--no-sched*

Disable scheduler event tracing (sched_* tracepoints and scheduler event recorder).
When this option is enabled, systing will not collect any scheduler-related events including:

* `sched_switch` - Task switching events
* `sched_waking` - Task waking events
* `sched_wakeup` - Task wakeup events
* `sched_wakeup_new` - New task wakeup events
* `sched_process_exit` - Process exit events

This option can be useful when you only want to collect stack traces, perf counters, or custom tracepoint events without the overhead of scheduler event processing.
Note that disabling scheduler events will result in an incomplete view of system activity in the generated Perfetto trace.

=== *--no-sleep-stack-traces*

Do not record stack traces when the task is in an uninterruptible sleep state.

=== *--no-stack-traces*

Do not record stack traces for the threads in the system.
This disables the perf style stack traces as well as the uninterruptible sleep stack traces.

=== *--only-recorder* _RECORDER_

Disable all recorders and only enable the specified ones.
This option can be specified multiple times to enable multiple recorders exclusively.
Use *--list-recorders* to see available recorders.

This is different from *--add-recorder* which adds recorders to the default enabled set.
*--only-recorder* provides explicit control over exactly which recorders are active.

Available recorders are the same as documented in *--add-recorder*.

Examples:
----
# Only record syscalls, disable everything else
# systing --only-recorder syscalls --duration 60

# Only record syscalls and cpu-stacks
# systing --only-recorder syscalls --only-recorder cpu-stacks --duration 60
----

=== *--perf-counter* _COUNTERNAME_

Record a perf counter for the given process.
This can be specified multiple times to record multiple perf counters.
This also accepts a glob pattern to match multiple perf counters.
The perf counters are global tracks and recorded per CPU, so if you wish to view the counters for a particlar section of a thread runtime you must find the CPU that thread is on at the given time and look for the counters on the track for that CPU.

=== *--pid* _PID_

Record only the process with the given PID.
Similar to cgroup, we will record any process that wakes up our PID, which may result in odd artifacts in the scheduler tracks.
This can be specified multiple times to record multiple PIDs.

=== *--process-sched-stats*

Record individual process scheduling statistics per CPU and per thread.
This is similar to *--cpu-sched-stats* but for each thread in the system.
This generates a lot of data and is not recommended for long traces.
This will generate a single track per thread that shows that threads current scheudling wakeup latency.

=== *--ringbuf-size-mb* _SIZE_

Specifies the size of the ring buffer in megabytes.
The default is 50Mib.
If you are having too many missed events you can increase this size.
NOTE: You will always have missed events for perf events, this is normal.
Only increase this if you are having misseed sched events, as that affects the trace quality.

=== *--sw-event*

If recording inside of a VM, this can be specified to enable the software events necessary to record stack traces.

=== *--syscalls*

Enable syscall tracing (raw_syscalls:sys_enter and sys_exit tracepoints).
When enabled, systing will record all system call entry and exit events for traced processes.
This generates detailed information about system call usage but can create large trace files.

Note: This option is equivalent to using `--add-recorder syscalls`.

Example:
----
# systing --syscalls --duration 60
----

=== *--trace-event* _EVENT_

This is a special option that takes a format similar to https://bpftrace.org[`bpftrace`].
Currently the supported events are only `usdt`, `uprobe`, `uretprobe`, `kprobe`, `kretprobe`, and `tracepoint`.
If using the userspace related events you must also specify *--trace-event-pid* to specify the PID of the process you want to trace.
The following is an exhaustive list of the supported formats

* `usdt:/path/to/executable:tracepoint_name:tracepoint_class`
* `uprobe:/path/to/executable:function_name`
* `uprobe:/path/to/executable:offset`
* `uprobe:/path/to/executable:function_name+offset`
* `uretprobe:/path/to/executable:function_name`
* `uretprobe:/path/to/executable:offset`
* `uretprobe:/path/to/executable:function_name+offset`
* `kprobe:kernel_function_name`
* `kprobe:kernel_function_name+offset`
* `kprobe:offset`
* `kretprobe:kernel_function_name`
* `kretprobe:offset`
* `tracepoint:subystem:tracepoint_name`

=== *--trace-event-pid* _PID_

This is to be paired with *--trace-event-pid*.
Any _PID_ specified here will have any of the userspace trace events specified applied to it.

=== *--trace-event-config* _CONFIG_

This must be parid with *--trace-event-pid* if you are using a userspace trace event.
This provides an optional configuration for complex trace event descriptions.
The configuration is a JSON file with the following format.

[source, json]
----
{
  "events": [
    {
      "name": "tracepoint_start",
      "event": "_EVENT_",
      "keys": [
        {
          "key_index": 0,
          "key_type": "long"
        }
      ]
    },
    {
      "name": "tracepoint_end",
      "event": "_EVENT_",
      "keys": [
        {
          "key_index": 0,
          "key_type": "long"
        }
      ]
    },
    {
      "name": "tracepoint_instant",
      "event": "_EVENT_",
      "percpu": true,
      "keys": [
        {
          "key_index": 0,
          "key_type": "long"
        }
      ]
    }
  ],
  "tracks": [
    {
      "track_name": "track_name",
      "ranges": [
        {
          "name": "range",
          "start": "tracepoint_start",
          "end": "tracepoint_end",
        }
      ],
    },
    {
      "track_name": "instant_track",
      "instants": [
        {
          "event": "tracepoint_instant",
        }
      ]
    }
  ]
  "stop_triggers": {
    "thresholds": [
      {
        "start": "tracepoint_start",
        "end": "tracepoint_end",
        "duration_us": 1000
      }
    ],
    "instants": [
      {
        "event": "tracepoint_instant"
      }
    ]
  }
}
----

`tracks` can be optionally specified to create a custom track of events for events.
There are two types of tracks, `ranges` and `instant`.
`ranges` will create a track that shows the start and end of a range of events, while `instants` will create a track that shows the instant events.
You can specify multiple `ranges` or `instants` per track.

`stop_triggers` can be optionally specified to stop the trace when a certain condition is met.
This is used in conjunction with the *--continuous* option.

`keys` is an optional set of extra data to be extracted from the trace event.
Currently only 1 is suspported.
The value will be attached to the trace event and be visible with the event in `perfetto`.
NOTE: For `tracepoint` events we use `raw_tracepoint`, which reads the args from the TP_EVENT definition, not what is found in /sys/kernel/debug/tracing/events/category/name/format.

`percpu` is set to true if the event is keyed to a CPU and not a specific thread.
These events will show up under the `Systing` track in `perfetto`, each event as it's own category and then each CPU having its own track.

=== *-v, --verbose*

Increase verbosity level.
This option can be specified multiple times to increase the amount of debugging information printed to stderr.

* No `-v` flags: Only warnings and errors (default)
* `-v`: Add informational messages about tool operation
* `-vv`: Add detailed debug messages for troubleshooting
* `-vvv` or more: Add trace-level messages including detailed library debugging from blazesym and debuginfod

Higher verbosity levels are particularly useful when troubleshooting symbol resolution issues or debuginfod connectivity problems.
Examples:
----
# Basic operation with minimal output
# systing --duration 60

# Show informational messages
# systing -v --duration 60

# Detailed debugging for troubleshooting
# systing -vv --enable-debuginfod --duration 60

# Maximum verbosity for library debugging
# systing -vvv --enable-debuginfod --duration 60
----

Example files for real world examples can be found in the `examples` directory.
