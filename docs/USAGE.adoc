= systing(8)
:doctype: manpage
:toc: true
:toclevels: 1

////
Style guide:
- one sentence per line
////

== Name

systing - a tracing tool for generating perfetto traces

== Synopsis

*systing* [_OPTIONS_]

== Description

systing is a tracing tool for generating perfetto traces of the system.
It was written with the intention of being a simple and easy to use tool for generating https://perfetto.dev[Perfetto] traces with the least amount of configuration possible.
It is opinionated about what is the most useful information to get out of the system for doing low level system performance investigations.

== Examples

Trace all the scheduling events and stack traces for all threads in the system for 60 seconds::
----
# systing --duration 60
----

Trace a specific qemu process and record every time it calls `v9fs_create`::
----
# systing --duration 60 --trace-event "usdt:/usr/bin/qemu-system-x86_64:qemu:v9fs_create" --trace-event-pid <pid>
----

Trace all processes that have libc loaded and record malloc calls (auto-discovery)::
----
# systing --duration 60 --trace-event "uprobe:libc.so.6:malloc"
----

== Options

=== *--add-recorder* _RECORDER_

Enable a specific recorder by name in addition to the default enabled recorders.
This option can be specified multiple times to enable multiple recorders.
Use *--list-recorders* to see available recorders and their default states.

Available recorders:

* `sched` - Scheduler event tracing (enabled by default)
* `syscalls` - Syscall tracing (disabled by default)
* `sleep-stacks` - Sleep stack traces (enabled by default)
* `cpu-stacks` - CPU perf stack traces (enabled by default)
* `network` - Network traffic recording (disabled by default) - Captures TCP/UDP send/receive operations, packet-level latency tracking, and queue management through multiple kernel instrumentation points
* `pystacks` - Python stack tracing (disabled by default)

Examples:
----
# Enable syscalls in addition to default recorders
# systing --add-recorder syscalls --duration 60

# Enable network traffic recording in addition to default recorders
# systing --add-recorder network --duration 60

# Enable both syscalls and network
# systing --add-recorder syscalls --add-recorder network --duration 60
----

=== *--cgroup* _PATH_

Record only processes that belong to this cgroup.
This can be specified multiple times to record multiple cgroups.

With this option we will still record processes that are not in the cgroup but that wakeup a process in our cgroup.
This creates odd artifacts in the scheduler tracks but is useful for debugging.

=== *--continuous* _SECONDS_

Run the trace continuously in a ringbuffer that lasts _SECONDS_.
This will not stop the trace after _SECONDS_ but will instead continue to run until the user stops it.
This is useful for long running traces where you want to keep the trace running and only stop it when you are done.
You can use this in conjunction with the `stop_triggers` option in the *--trace-event-config* option to stop the trace when a certain condition is met.

An example usecase is when attempting to catch a rare occurring latency event.

=== *--cpu-frequency*

Record the CPU frequency of every CPU in the system.
When this is enabled systing will record the CPU frequency of every CPU in the system every 100ms.
This will be added a global track per-CPU in the trace.

=== *--cpu-sched-stats*

Record individual CPU scheduling statistics per CPU and per thread.
This generates a lot of data and is not recommended for long traces.
This will generate 2 tracks in the global track for each CPU in the system.
The first will contain the number of entities in the runqueue for each CPU at the given timestamp.
The second is the current wakeup latency for this CPU at the given timestamp.

=== *--duration*

Specifies the duration of the trace in seconds.

=== *--enable-debuginfod*

Enable debuginfod for enhanced symbol resolution.
When enabled, systing will attempt to fetch debug information for binaries using the debuginfod protocol.
This can significantly improve the quality of stack traces by providing more accurate symbol names and source code information.
It will also increase the amount of time required to generate traces.

To use this feature, you must set the `DEBUGINFOD_URLS` environment variable to point to one or more debuginfod servers.
For example:
----
export DEBUGINFOD_URLS="https://debuginfod.fedoraporject.org/"
# systing --enable-debuginfod --duration 60
----

If debuginfod is not available or fails to fetch debug information, systing will fall back to the default symbol resolution methods.
This option is disabled by default to avoid unexpected network requests.

=== *--list-recorders*

List all available recorders and their default states.
This is useful for discovering which recorders are available and which ones are enabled by default.
Use this in conjunction with *--add-recorder* or *--only-recorder* to control which recorders are active.

Example:
----
# systing --list-recorders
Available recorders:
  sched          - Scheduler event tracing (on by default)
  syscalls       - Syscall tracing
  sleep-stacks   - Sleep stack traces (on by default)
  cpu-stacks     - CPU perf stack traces (on by default)
  network        - Network traffic recording
  pystacks       - Python stack tracing
----

=== *--no-cpu-stack-traces*

Do not record the `perf` style stack traces for tasks while they're running.

=== *--no-sched*

Disable scheduler event tracing (sched_* tracepoints and scheduler event recorder).
When this option is enabled, systing will not collect any scheduler-related events including:

* `sched_switch` - Task switching events
* `sched_waking` - Task waking events
* `sched_wakeup` - Task wakeup events
* `sched_wakeup_new` - New task wakeup events
* `sched_process_exit` - Process exit events

This option can be useful when you only want to collect stack traces, perf counters, or custom tracepoint events without the overhead of scheduler event processing.
Note that disabling scheduler events will result in an incomplete view of system activity in the generated Perfetto trace.

=== *--no-sleep-stack-traces*

Do not record stack traces when the task is in an uninterruptible sleep state.

=== *--no-stack-traces*

Do not record stack traces for the threads in the system.
This disables the perf style stack traces as well as the uninterruptible sleep stack traces.

=== *--only-recorder* _RECORDER_

Disable all recorders and only enable the specified ones.
This option can be specified multiple times to enable multiple recorders exclusively.
Use *--list-recorders* to see available recorders.

This is different from *--add-recorder* which adds recorders to the default enabled set.
*--only-recorder* provides explicit control over exactly which recorders are active.

Available recorders are the same as documented in *--add-recorder*.

Examples:
----
# Only record syscalls, disable everything else
# systing --only-recorder syscalls --duration 60

# Only record network traffic, disable everything else
# systing --only-recorder network --duration 60

# Only record syscalls and cpu-stacks
# systing --only-recorder syscalls --only-recorder cpu-stacks --duration 60
----

=== *--perf-counter* _COUNTERNAME_

Record a perf counter for the given process.
This can be specified multiple times to record multiple perf counters.
This also accepts a glob pattern to match multiple perf counters.
The perf counters are global tracks and recorded per CPU, so if you wish to view the counters for a particlar section of a thread runtime you must find the CPU that thread is on at the given time and look for the counters on the track for that CPU.

=== *--pid* _PID_

Record only the process with the given PID.
Similar to cgroup, we will record any process that wakes up our PID, which may result in odd artifacts in the scheduler tracks.
This can be specified multiple times to record multiple PIDs.

=== *--process-sched-stats*

Record individual process scheduling statistics per CPU and per thread.
This is similar to *--cpu-sched-stats* but for each thread in the system.
This generates a lot of data and is not recommended for long traces.
This will generate a single track per thread that shows that threads current scheudling wakeup latency.

=== *--ringbuf-size-mb* _SIZE_

Specifies the size of the ring buffer in megabytes.
The default is 50Mib.
If you are having too many missed events you can increase this size.
NOTE: You will always have missed events for perf events, this is normal.
Only increase this if you are having misseed sched events, as that affects the trace quality.

=== *--sw-event*

If recording inside of a VM, this can be specified to enable the software events necessary to record stack traces.

=== *--syscalls*

Enable syscall tracing (raw_syscalls:sys_enter and sys_exit tracepoints).
When enabled, systing will record all system call entry and exit events for traced processes.
This generates detailed information about system call usage but can create large trace files.

Note: This option is equivalent to using `--add-recorder syscalls`.

Example:
----
# systing --syscalls --duration 60
----

=== *--trace-event* _EVENT_

This is a special option that takes a format similar to https://bpftrace.org[`bpftrace`].
Currently the supported events are `usdt`, `uprobe`, `uretprobe`, `kprobe`, `kretprobe`, and `tracepoint`.
For userspace related events (uprobe, uretprobe, usdt), you can optionally specify *--trace-event-pid* to target specific processes.
If no PIDs are specified, systing will automatically discover and attach to all processes that have the specified binary or library loaded.
The following is an exhaustive list of the supported formats

* `usdt:/path/to/executable:tracepoint_name:tracepoint_class`
* `uprobe:/path/to/executable:function_name`
* `uprobe:/path/to/executable:offset`
* `uprobe:/path/to/executable:function_name+offset`
* `uretprobe:/path/to/executable:function_name`
* `uretprobe:/path/to/executable:offset`
* `uretprobe:/path/to/executable:function_name+offset`
* `kprobe:kernel_function_name`
* `kprobe:kernel_function_name+offset`
* `kprobe:offset`
* `kretprobe:kernel_function_name`
* `kretprobe:offset`
* `tracepoint:subystem:tracepoint_name`

=== *--trace-event-pid* _PID_

Optional parameter for userspace trace events (uprobe, uretprobe, usdt).
When specified, trace events will be attached only to the given PID(s).
When omitted, systing will automatically discover all processes that have the specified binary or library loaded and attach to all of them.
This option can be specified multiple times to trace multiple specific processes.

=== *--trace-event-config* _CONFIG_

This is used with trace events to provide complex configurations.
This provides an optional configuration for complex trace event descriptions.
The configuration is a JSON file with the following format.

[source, json]
----
{
  "events": [
    {
      "name": "tracepoint_start",
      "event": "_EVENT_",
      "args": [
        {
          "arg_index": 0,
          "arg_type": "long",
          "arg_name": "value"
        }
      ]
    },
    {
      "name": "tracepoint_end",
      "event": "_EVENT_",
      "args": [
        {
          "arg_index": 0,
          "arg_type": "long",
          "arg_name": "value"
        }
      ]
    },
    {
      "name": "tracepoint_instant",
      "event": "_EVENT_",
      "scope": "cpu",
      "stack": true,
      "args": [
        {
          "arg_index": 0,
          "arg_type": "long",
          "arg_name": "value"
        }
      ]
    }
  ],
  "tracks": [
    {
      "track_name": "track_name",
      "ranges": [
        {
          "name": "range",
          "start": "tracepoint_start",
          "end": "tracepoint_end",
        }
      ],
    },
    {
      "track_name": "instant_track",
      "instants": [
        {
          "event": "tracepoint_instant",
        }
      ]
    }
  ]
  "stop_triggers": {
    "thresholds": [
      {
        "start": "tracepoint_start",
        "end": "tracepoint_end",
        "duration_us": 1000
      }
    ],
    "instants": [
      {
        "event": "tracepoint_instant"
      }
    ]
  }
}
----

`tracks` can be optionally specified to create a custom track of events for events.
There are two types of tracks, `ranges` and `instant`.
`ranges` will create a track that shows the start and end of a range of events, while `instants` will create a track that shows the instant events.
You can specify multiple `ranges` or `instants` per track.

`stop_triggers` can be optionally specified to stop the trace when a certain condition is met.
This is used in conjunction with the *--continuous* option.

`args` is an optional set of arguments to be extracted from the probe event.
Up to 4 arguments can be captured per event.
The captured arguments will show up as debug annotations on the event in the trace, providing additional context when viewing in `perfetto`.
Each arg specifies an `arg_index` (0-based), `arg_type`, and `arg_name` (the name of the debug annotation).

Available arg types:

* `"string"` - Captures a string pointer argument (requires `arg_index`)
* `"long"` - Captures a 64-bit integer argument (requires `arg_index`)
* `"retval"` - Captures the function return value (only valid for `kretprobe` and `uretprobe` events; `arg_index` is optional and ignored)

NOTE: For `tracepoint` events we use `raw_tracepoint`, which reads the args from the TP_EVENT definition, not what is found in /sys/kernel/debug/tracing/events/category/name/format.

`scope` controls how the event is attributed in the trace output. Valid values:

* `"thread"` (default) - Event is attributed to the specific thread (TGIDPID).
* `"process"` - Event is attributed to the process (TGID). Useful for async tasks that may migrate between threads, where start and end markers can fire on different threads.
* `"cpu"` - Event is attributed to the CPU. These events will show up under the `Systing` track in `perfetto`, each event as its own category and then each CPU having its own track.

`stack` is an optional field (defaults to `false`).
When set to `true`, systing will capture and emit a stack trace whenever this event fires.
The stack trace will appear in the perfetto trace alongside the event, showing the call stack at the point where the event occurred.
This is useful for debugging and performance analysis.

==== Userspace Marker Events

Userspace applications can emit self-describing trace events without any special libraries or configuration.
Enable marker collection with `--add-recorder markers`, then call `faccessat2` with the sentinel mode value `-975`:

[source, c]
----
#include <sys/syscall.h>
#include <unistd.h>

#define SYSTING_MARKER_MODE (-975)
#define SYSTING_MARKER_START   0
#define SYSTING_MARKER_END     1
#define SYSTING_MARKER_INSTANT 2

// Start a range (name format: "TrackName:EventName", or just "EventName" for default track)
syscall(SYS_faccessat2, SYSTING_MARKER_START,   "Training:fwd_bwd",    SYSTING_MARKER_MODE, 0);
// End the range
syscall(SYS_faccessat2, SYSTING_MARKER_END,     "Training:fwd_bwd",    SYSTING_MARKER_MODE, 0);
// Emit an instant event
syscall(SYS_faccessat2, SYSTING_MARKER_INSTANT, "Training:checkpoint", SYSTING_MARKER_MODE, 0);
----

The calling convention:

* `dirfd` (arg 0): event type — `0` = range start, `1` = range end, `2` = instant
* `pathname` (arg 1): `"TrackName:EventName"` — the first colon separates track from event name.
  If no colon is present, the track defaults to `"Markers"`.
  Additional colons are treated as part of the event name (e.g. `"Track:a:b"` → track=`"Track"`, name=`"a:b"`).
* `mode` (arg 2): must be `-975` to identify the call as a systing marker.
  The BPF check compares only the lower 32 bits, so both sign-extended and
  zero-extended representations of `-975` are accepted — passing the value as
  a C `int`, a Python `ctypes` integer, or an unsigned `0xFFFFFC31` all work.
* `flags` (arg 3): ignored

Start/end ranges are matched by thread (same TGIDPID) and `(track, event)` name pair.
No JSON config is required — markers are collected into their own tracks automatically.

NOTE: Marker collection is off by default. Enable it with `--add-recorder markers`.

=== *-v, --verbose*

Increase verbosity level.
This option can be specified multiple times to increase the amount of debugging information printed to stderr.

* No `-v` flags: Only warnings and errors (default)
* `-v`: Add informational messages about tool operation
* `-vv`: Add detailed debug messages for troubleshooting
* `-vvv` or more: Add trace-level messages including detailed library debugging from blazesym and debuginfod

Higher verbosity levels are particularly useful when troubleshooting symbol resolution issues or debuginfod connectivity problems.
Examples:
----
# Basic operation with minimal output
# systing --duration 60

# Show informational messages
# systing -v --duration 60

# Detailed debugging for troubleshooting
# systing -vv --enable-debuginfod --duration 60

# Maximum verbosity for library debugging
# systing -vvv --enable-debuginfod --duration 60
----

Example files for real world examples can be found in the `examples` directory.
